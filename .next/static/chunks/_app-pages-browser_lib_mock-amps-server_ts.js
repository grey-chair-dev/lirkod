"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_mock-amps-server_ts"],{

/***/ "(app-pages-browser)/./lib/mock-amps-server.ts":
/*!*********************************!*\
  !*** ./lib/mock-amps-server.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MockAmpsServer: function() { return /* binding */ MockAmpsServer; },\n/* harmony export */   mockAmpsServer: function() { return /* binding */ mockAmpsServer; }\n/* harmony export */ });\n// Mock AMPS Server for Development and Testing\n// This simulates a real AMPS system for development purposes\nclass MockAmpsServer {\n    // Simulate API endpoints\n    async handleRequest(endpoint, method, body) {\n        console.log(\"Mock AMPS API: \".concat(method, \" \").concat(endpoint));\n        switch(endpoint){\n            case \"/api/connect\":\n                return this.handleConnect(body);\n            case \"/api/disconnect\":\n                return this.handleDisconnect();\n            case \"/api/status\":\n                return this.handleGetStatus();\n            case \"/api/heartbeat\":\n                return this.handleHeartbeat();\n            case \"/api/sessions\":\n                if (method === \"POST\") {\n                    return this.handleCreateSession(body);\n                }\n                return this.handleGetSessions();\n            case \"/api/sessions/current\":\n                return this.handleGetCurrentSession();\n            case \"/api/sessions/leave\":\n                return this.handleLeaveSession();\n            case \"/api/sessions/control\":\n                return this.handleControlPlayback(body);\n            case \"/api/sessions/seek\":\n                return this.handleSeek(body);\n            case \"/api/sessions/volume\":\n                return this.handleSetVolume(body);\n            case \"/api/sessions/queue\":\n                if (method === \"POST\") {\n                    return this.handleAddToQueue(body);\n                }\n                return this.handleGetQueue();\n            case \"/api/content/search\":\n                return this.handleSearchContent(endpoint);\n            default:\n                if (endpoint.startsWith(\"/api/sessions/\") && endpoint.includes(\"/join\")) {\n                    const sessionId = endpoint.split(\"/\")[3];\n                    return this.handleJoinSession(sessionId);\n                }\n                if (endpoint.startsWith(\"/api/sessions/queue/\") && method === \"DELETE\") {\n                    const queueItemId = endpoint.split(\"/\")[4];\n                    return this.handleRemoveFromQueue(queueItemId);\n                }\n                if (endpoint.startsWith(\"/api/content/\")) {\n                    const contentId = endpoint.split(\"/\")[3];\n                    return this.handleGetContent(contentId);\n                }\n                throw new Error(\"Unknown endpoint: \".concat(endpoint));\n        }\n    }\n    async handleConnect(body) {\n        this.isConnected = true;\n        this.systemStatus.connected = true;\n        this.startHeartbeat();\n        return {\n            success: true,\n            data: {\n                clientId: \"mock-client-\" + Date.now(),\n                capabilities: body.capabilities || []\n            }\n        };\n    }\n    async handleDisconnect() {\n        this.isConnected = false;\n        this.systemStatus.connected = false;\n        this.currentSessionId = null;\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = undefined;\n        }\n        return {\n            success: true\n        };\n    }\n    async handleGetStatus() {\n        this.systemStatus.lastHeartbeat = new Date().toISOString();\n        this.systemStatus.sessions.active = this.sessions.size;\n        this.systemStatus.sessions.total = this.sessions.size;\n        return {\n            data: this.systemStatus\n        };\n    }\n    async handleHeartbeat() {\n        this.systemStatus.lastHeartbeat = new Date().toISOString();\n        return {\n            success: true\n        };\n    }\n    async handleCreateSession(body) {\n        const sessionId = \"session-\" + Date.now();\n        const session = {\n            id: sessionId,\n            name: body.name || \"New Session\",\n            status: \"active\",\n            participants: 1,\n            queue: [],\n            settings: {\n                volume: 80,\n                shuffle: false,\n                repeat: false,\n                ...body.settings\n            },\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        this.sessions.set(sessionId, session);\n        this.currentSessionId = sessionId;\n        return {\n            data: session\n        };\n    }\n    async handleJoinSession(sessionId) {\n        const session = this.sessions.get(sessionId);\n        if (!session) {\n            throw new Error(\"Session not found\");\n        }\n        session.participants++;\n        session.updatedAt = new Date().toISOString();\n        this.currentSessionId = sessionId;\n        return {\n            data: session\n        };\n    }\n    async handleGetCurrentSession() {\n        if (!this.currentSessionId) {\n            return {\n                data: null\n            };\n        }\n        const session = this.sessions.get(this.currentSessionId);\n        return {\n            data: session || null\n        };\n    }\n    async handleLeaveSession() {\n        if (this.currentSessionId) {\n            const session = this.sessions.get(this.currentSessionId);\n            if (session) {\n                session.participants = Math.max(0, session.participants - 1);\n                session.updatedAt = new Date().toISOString();\n            }\n            this.currentSessionId = null;\n        }\n        return {\n            success: true\n        };\n    }\n    async handleControlPlayback(body) {\n        if (!this.currentSessionId) {\n            throw new Error(\"No active session\");\n        }\n        const session = this.sessions.get(this.currentSessionId);\n        if (!session) {\n            throw new Error(\"Session not found\");\n        }\n        switch(body.action){\n            case \"play\":\n                session.status = \"active\";\n                if (!session.currentTrack && session.queue.length > 0) {\n                    const nextTrack = session.queue[0];\n                    session.currentTrack = {\n                        id: nextTrack.id,\n                        title: nextTrack.title,\n                        artist: nextTrack.artist,\n                        duration: nextTrack.duration,\n                        position: 0\n                    };\n                }\n                break;\n            case \"pause\":\n                session.status = \"paused\";\n                break;\n            case \"stop\":\n                session.status = \"inactive\";\n                session.currentTrack = undefined;\n                break;\n            case \"next\":\n                if (session.queue.length > 0) {\n                    const nextTrack = session.queue[0];\n                    session.currentTrack = {\n                        id: nextTrack.id,\n                        title: nextTrack.title,\n                        artist: nextTrack.artist,\n                        duration: nextTrack.duration,\n                        position: 0\n                    };\n                    session.queue.shift();\n                }\n                break;\n            case \"previous\":\n                // Simple implementation - just restart current track\n                if (session.currentTrack) {\n                    session.currentTrack.position = 0;\n                }\n                break;\n        }\n        session.updatedAt = new Date().toISOString();\n        return {\n            success: true\n        };\n    }\n    async handleSeek(body) {\n        if (!this.currentSessionId) {\n            throw new Error(\"No active session\");\n        }\n        const session = this.sessions.get(this.currentSessionId);\n        if (!session || !session.currentTrack) {\n            throw new Error(\"No active track\");\n        }\n        session.currentTrack.position = Math.max(0, Math.min(body.position, session.currentTrack.duration));\n        session.updatedAt = new Date().toISOString();\n        return {\n            success: true\n        };\n    }\n    async handleSetVolume(body) {\n        if (!this.currentSessionId) {\n            throw new Error(\"No active session\");\n        }\n        const session = this.sessions.get(this.currentSessionId);\n        if (!session) {\n            throw new Error(\"Session not found\");\n        }\n        session.settings.volume = Math.max(0, Math.min(100, body.volume));\n        session.updatedAt = new Date().toISOString();\n        return {\n            success: true\n        };\n    }\n    async handleAddToQueue(body) {\n        if (!this.currentSessionId) {\n            throw new Error(\"No active session\");\n        }\n        const session = this.sessions.get(this.currentSessionId);\n        if (!session) {\n            throw new Error(\"Session not found\");\n        }\n        const queueItem = {\n            id: \"queue-\" + Date.now(),\n            contentId: body.contentId,\n            title: \"Track \".concat(body.contentId),\n            artist: \"Mock Artist\",\n            duration: 180,\n            addedBy: \"mock-user\",\n            addedAt: new Date().toISOString(),\n            priority: body.priority || 0\n        };\n        session.queue.push(queueItem);\n        session.updatedAt = new Date().toISOString();\n        return {\n            data: queueItem\n        };\n    }\n    async handleGetQueue() {\n        if (!this.currentSessionId) {\n            return {\n                data: []\n            };\n        }\n        const session = this.sessions.get(this.currentSessionId);\n        return {\n            data: (session === null || session === void 0 ? void 0 : session.queue) || []\n        };\n    }\n    async handleRemoveFromQueue(queueItemId) {\n        if (!this.currentSessionId) {\n            throw new Error(\"No active session\");\n        }\n        const session = this.sessions.get(this.currentSessionId);\n        if (!session) {\n            throw new Error(\"Session not found\");\n        }\n        session.queue = session.queue.filter((item)=>item.id !== queueItemId);\n        session.updatedAt = new Date().toISOString();\n        return {\n            success: true\n        };\n    }\n    async handleSearchContent(endpoint) {\n        const url = new URL(\"http://localhost\" + endpoint);\n        const query = url.searchParams.get(\"q\") || \"\";\n        const limit = parseInt(url.searchParams.get(\"limit\") || \"50\");\n        // Mock search results\n        const results = Array.from({\n            length: Math.min(limit, 10)\n        }, (_, i)=>({\n                id: \"content-\".concat(i + 1),\n                title: \"Mock Track \".concat(i + 1),\n                artist: \"Mock Artist \".concat(i + 1),\n                duration: 120 + i * 30,\n                audioUrl: \"/mock-audio/track-\".concat(i + 1, \".mp3\"),\n                metadata: {\n                    genre: [\n                        \"Pop\",\n                        \"Rock\",\n                        \"Electronic\"\n                    ][i % 3],\n                    year: 2020 + i % 4,\n                    bpm: 120 + i * 10,\n                    key: [\n                        \"C\",\n                        \"D\",\n                        \"E\",\n                        \"F\",\n                        \"G\"\n                    ][i % 5]\n                }\n            }));\n        return {\n            data: results\n        };\n    }\n    async handleGetContent(contentId) {\n        return {\n            data: {\n                id: contentId,\n                title: \"Mock Track \".concat(contentId),\n                artist: \"Mock Artist\",\n                duration: 180,\n                audioUrl: \"/mock-audio/\".concat(contentId, \".mp3\"),\n                metadata: {\n                    genre: \"Pop\",\n                    year: 2023,\n                    bpm: 120,\n                    key: \"C\"\n                }\n            }\n        };\n    }\n    startHeartbeat() {\n        this.heartbeatInterval = setInterval(()=>{\n            this.systemStatus.lastHeartbeat = new Date().toISOString();\n        }, 30000);\n    }\n    // Simulate track progression\n    startTrackProgression() {\n        setInterval(()=>{\n            if (this.currentSessionId) {\n                const session = this.sessions.get(this.currentSessionId);\n                if ((session === null || session === void 0 ? void 0 : session.currentTrack) && session.status === \"active\") {\n                    session.currentTrack.position += 1;\n                    if (session.currentTrack.position >= session.currentTrack.duration) {\n                        // Track finished, play next\n                        if (session.queue.length > 0) {\n                            const nextTrack = session.queue.shift();\n                            session.currentTrack = {\n                                id: nextTrack.id,\n                                title: nextTrack.title,\n                                artist: nextTrack.artist,\n                                duration: nextTrack.duration,\n                                position: 0\n                            };\n                        } else {\n                            session.currentTrack = undefined;\n                            session.status = \"inactive\";\n                        }\n                    }\n                    session.updatedAt = new Date().toISOString();\n                }\n            }\n        }, 1000) // Update every second\n        ;\n    }\n    constructor(){\n        this.sessions = new Map();\n        this.currentSessionId = null;\n        this.isConnected = false;\n        this.systemStatus = {\n            connected: false,\n            version: \"1.0.0-mock\",\n            hardware: {\n                audio: \"connected\",\n                network: \"connected\",\n                storage: \"available\"\n            },\n            sessions: {\n                active: 0,\n                total: 0\n            },\n            lastHeartbeat: new Date().toISOString()\n        };\n    }\n}\n// Export singleton instance\nconst mockAmpsServer = new MockAmpsServer();\n// Start track progression simulation\nmockAmpsServer.startTrackProgression();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2NrLWFtcHMtc2VydmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsK0NBQStDO0FBQy9DLDZEQUE2RDtBQWdEdEQsTUFBTUE7SUF3QlgseUJBQXlCO0lBQ3pCLE1BQU1DLGNBQWNDLFFBQWdCLEVBQUVDLE1BQWMsRUFBRUMsSUFBVSxFQUFnQjtRQUM5RUMsUUFBUUMsR0FBRyxDQUFDLGtCQUE0QkosT0FBVkMsUUFBTyxLQUFZLE9BQVREO1FBRXhDLE9BQVFBO1lBQ04sS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ0ssYUFBYSxDQUFDSDtZQUU1QixLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDSSxnQkFBZ0I7WUFFOUIsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ0MsZUFBZTtZQUU3QixLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDQyxlQUFlO1lBRTdCLEtBQUs7Z0JBQ0gsSUFBSVAsV0FBVyxRQUFRO29CQUNyQixPQUFPLElBQUksQ0FBQ1EsbUJBQW1CLENBQUNQO2dCQUNsQztnQkFDQSxPQUFPLElBQUksQ0FBQ1EsaUJBQWlCO1lBRS9CLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUNDLHVCQUF1QjtZQUVyQyxLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDQyxrQkFBa0I7WUFFaEMsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ0MscUJBQXFCLENBQUNYO1lBRXBDLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUNZLFVBQVUsQ0FBQ1o7WUFFekIsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ2EsZUFBZSxDQUFDYjtZQUU5QixLQUFLO2dCQUNILElBQUlELFdBQVcsUUFBUTtvQkFDckIsT0FBTyxJQUFJLENBQUNlLGdCQUFnQixDQUFDZDtnQkFDL0I7Z0JBQ0EsT0FBTyxJQUFJLENBQUNlLGNBQWM7WUFFNUIsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNsQjtZQUVsQztnQkFDRSxJQUFJQSxT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eEJDLFVBQVVILFVBQVVHLFFBQVE7Z0NBQzVCQyxVQUFVOzRCQUNaO3dCQUNGLE9BQU87NEJBQ0x2QixRQUFRaUIsWUFBWSxHQUFHeEI7NEJBQ3ZCTyxRQUFRRyxNQUFNLEdBQUc7d0JBQ25CO29CQUNGO29CQUNBSCxRQUFRVyxTQUFTLEdBQUcsSUFBSXhCLE9BQU9RLFdBQVc7Z0JBQzVDO1lBQ0Y7UUFDRixHQUFHLE1BQU0sc0JBQXNCOztJQUNqQztJQTFZQXlELGFBQWM7YUFOTnhELFdBQXlDLElBQUl5RDthQUM3Qy9ELG1CQUFrQzthQUVsQ1YsY0FBdUI7UUFJN0IsSUFBSSxDQUFDQyxZQUFZLEdBQUc7WUFDbEJDLFdBQVc7WUFDWHdFLFNBQVM7WUFDVEMsVUFBVTtnQkFDUkMsT0FBTztnQkFDUEMsU0FBUztnQkFDVEMsU0FBUztZQUNYO1lBQ0E5RCxVQUFVO2dCQUNSQyxRQUFRO2dCQUNSRSxPQUFPO1lBQ1Q7WUFDQUwsZUFBZSxJQUFJUCxPQUFPUSxXQUFXO1FBQ3ZDO0lBQ0Y7QUE0WEY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWdFLGlCQUFpQixJQUFJOUcsaUJBQWdCO0FBRWxELHFDQUFxQztBQUNyQzhHLGVBQWVSLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9jay1hbXBzLXNlcnZlci50cz8xNmZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1vY2sgQU1QUyBTZXJ2ZXIgZm9yIERldmVsb3BtZW50IGFuZCBUZXN0aW5nXG4vLyBUaGlzIHNpbXVsYXRlcyBhIHJlYWwgQU1QUyBzeXN0ZW0gZm9yIGRldmVsb3BtZW50IHB1cnBvc2VzXG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9ja0FtcHNTZXNzaW9uIHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICdpbmFjdGl2ZScgfCAncGF1c2VkJyB8ICdlcnJvcidcbiAgY3VycmVudFRyYWNrPzoge1xuICAgIGlkOiBzdHJpbmdcbiAgICB0aXRsZTogc3RyaW5nXG4gICAgYXJ0aXN0OiBzdHJpbmdcbiAgICBkdXJhdGlvbjogbnVtYmVyXG4gICAgcG9zaXRpb246IG51bWJlclxuICB9XG4gIHBhcnRpY2lwYW50czogbnVtYmVyXG4gIHF1ZXVlOiBBcnJheTx7XG4gICAgaWQ6IHN0cmluZ1xuICAgIGNvbnRlbnRJZDogc3RyaW5nXG4gICAgdGl0bGU6IHN0cmluZ1xuICAgIGFydGlzdDogc3RyaW5nXG4gICAgZHVyYXRpb246IG51bWJlclxuICAgIGFkZGVkQnk6IHN0cmluZ1xuICAgIGFkZGVkQXQ6IHN0cmluZ1xuICAgIHByaW9yaXR5OiBudW1iZXJcbiAgfT5cbiAgc2V0dGluZ3M6IHtcbiAgICB2b2x1bWU6IG51bWJlclxuICAgIHNodWZmbGU6IGJvb2xlYW5cbiAgICByZXBlYXQ6IGJvb2xlYW5cbiAgfVxuICBjcmVhdGVkQXQ6IHN0cmluZ1xuICB1cGRhdGVkQXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vY2tBbXBzU3lzdGVtU3RhdHVzIHtcbiAgY29ubmVjdGVkOiBib29sZWFuXG4gIHZlcnNpb246IHN0cmluZ1xuICBoYXJkd2FyZToge1xuICAgIGF1ZGlvOiAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnIHwgJ2Vycm9yJ1xuICAgIG5ldHdvcms6ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCcgfCAnZXJyb3InXG4gICAgc3RvcmFnZTogJ2F2YWlsYWJsZScgfCAnbG93JyB8ICdlcnJvcidcbiAgfVxuICBzZXNzaW9uczoge1xuICAgIGFjdGl2ZTogbnVtYmVyXG4gICAgdG90YWw6IG51bWJlclxuICB9XG4gIGxhc3RIZWFydGJlYXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgTW9ja0FtcHNTZXJ2ZXIge1xuICBwcml2YXRlIHNlc3Npb25zOiBNYXA8c3RyaW5nLCBNb2NrQW1wc1Nlc3Npb24+ID0gbmV3IE1hcCgpXG4gIHByaXZhdGUgY3VycmVudFNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBzeXN0ZW1TdGF0dXM6IE1vY2tBbXBzU3lzdGVtU3RhdHVzXG4gIHByaXZhdGUgaXNDb25uZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZVxuICBwcml2YXRlIGhlYXJ0YmVhdEludGVydmFsPzogTm9kZUpTLlRpbWVvdXRcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN5c3RlbVN0YXR1cyA9IHtcbiAgICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgICB2ZXJzaW9uOiAnMS4wLjAtbW9jaycsXG4gICAgICBoYXJkd2FyZToge1xuICAgICAgICBhdWRpbzogJ2Nvbm5lY3RlZCcsXG4gICAgICAgIG5ldHdvcms6ICdjb25uZWN0ZWQnLFxuICAgICAgICBzdG9yYWdlOiAnYXZhaWxhYmxlJ1xuICAgICAgfSxcbiAgICAgIHNlc3Npb25zOiB7XG4gICAgICAgIGFjdGl2ZTogMCxcbiAgICAgICAgdG90YWw6IDBcbiAgICAgIH0sXG4gICAgICBsYXN0SGVhcnRiZWF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9XG4gIH1cblxuICAvLyBTaW11bGF0ZSBBUEkgZW5kcG9pbnRzXG4gIGFzeW5jIGhhbmRsZVJlcXVlc3QoZW5kcG9pbnQ6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGJvZHk/OiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnNvbGUubG9nKGBNb2NrIEFNUFMgQVBJOiAke21ldGhvZH0gJHtlbmRwb2ludH1gKVxuXG4gICAgc3dpdGNoIChlbmRwb2ludCkge1xuICAgICAgY2FzZSAnL2FwaS9jb25uZWN0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ29ubmVjdChib2R5KVxuICAgICAgXG4gICAgICBjYXNlICcvYXBpL2Rpc2Nvbm5lY3QnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEaXNjb25uZWN0KClcbiAgICAgIFxuICAgICAgY2FzZSAnL2FwaS9zdGF0dXMnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVHZXRTdGF0dXMoKVxuICAgICAgXG4gICAgICBjYXNlICcvYXBpL2hlYXJ0YmVhdCc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUhlYXJ0YmVhdCgpXG4gICAgICBcbiAgICAgIGNhc2UgJy9hcGkvc2Vzc2lvbnMnOlxuICAgICAgICBpZiAobWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDcmVhdGVTZXNzaW9uKGJvZHkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlR2V0U2Vzc2lvbnMoKVxuICAgICAgXG4gICAgICBjYXNlICcvYXBpL3Nlc3Npb25zL2N1cnJlbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVHZXRDdXJyZW50U2Vzc2lvbigpXG4gICAgICBcbiAgICAgIGNhc2UgJy9hcGkvc2Vzc2lvbnMvbGVhdmUnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVMZWF2ZVNlc3Npb24oKVxuICAgICAgXG4gICAgICBjYXNlICcvYXBpL3Nlc3Npb25zL2NvbnRyb2wnOlxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDb250cm9sUGxheWJhY2soYm9keSlcbiAgICAgIFxuICAgICAgY2FzZSAnL2FwaS9zZXNzaW9ucy9zZWVrJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2Vlayhib2R5KVxuICAgICAgXG4gICAgICBjYXNlICcvYXBpL3Nlc3Npb25zL3ZvbHVtZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNldFZvbHVtZShib2R5KVxuICAgICAgXG4gICAgICBjYXNlICcvYXBpL3Nlc3Npb25zL3F1ZXVlJzpcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQWRkVG9RdWV1ZShib2R5KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUdldFF1ZXVlKClcbiAgICAgIFxuICAgICAgY2FzZSAnL2FwaS9jb250ZW50L3NlYXJjaCc6XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlYXJjaENvbnRlbnQoZW5kcG9pbnQpXG4gICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChlbmRwb2ludC5zdGFydHNXaXRoKCcvYXBpL3Nlc3Npb25zLycpICYmIGVuZHBvaW50LmluY2x1ZGVzKCcvam9pbicpKSB7XG4gICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gZW5kcG9pbnQuc3BsaXQoJy8nKVszXVxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUpvaW5TZXNzaW9uKHNlc3Npb25JZClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aCgnL2FwaS9zZXNzaW9ucy9xdWV1ZS8nKSAmJiBtZXRob2QgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgY29uc3QgcXVldWVJdGVtSWQgPSBlbmRwb2ludC5zcGxpdCgnLycpWzRdXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVtb3ZlRnJvbVF1ZXVlKHF1ZXVlSXRlbUlkKVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRwb2ludC5zdGFydHNXaXRoKCcvYXBpL2NvbnRlbnQvJykpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50SWQgPSBlbmRwb2ludC5zcGxpdCgnLycpWzNdXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlR2V0Q29udGVudChjb250ZW50SWQpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGVuZHBvaW50OiAke2VuZHBvaW50fWApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVDb25uZWN0KGJvZHk6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWVcbiAgICB0aGlzLnN5c3RlbVN0YXR1cy5jb25uZWN0ZWQgPSB0cnVlXG4gICAgdGhpcy5zdGFydEhlYXJ0YmVhdCgpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsaWVudElkOiAnbW9jay1jbGllbnQtJyArIERhdGUubm93KCksXG4gICAgICAgIGNhcGFiaWxpdGllczogYm9keS5jYXBhYmlsaXRpZXMgfHwgW11cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZURpc2Nvbm5lY3QoKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLnN5c3RlbVN0YXR1cy5jb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuY3VycmVudFNlc3Npb25JZCA9IG51bGxcbiAgICBcbiAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdEludGVydmFsKVxuICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlR2V0U3RhdHVzKCk6IFByb21pc2U8YW55PiB7XG4gICAgdGhpcy5zeXN0ZW1TdGF0dXMubGFzdEhlYXJ0YmVhdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIHRoaXMuc3lzdGVtU3RhdHVzLnNlc3Npb25zLmFjdGl2ZSA9IHRoaXMuc2Vzc2lvbnMuc2l6ZVxuICAgIHRoaXMuc3lzdGVtU3RhdHVzLnNlc3Npb25zLnRvdGFsID0gdGhpcy5zZXNzaW9ucy5zaXplXG4gICAgXG4gICAgcmV0dXJuIHsgZGF0YTogdGhpcy5zeXN0ZW1TdGF0dXMgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVIZWFydGJlYXQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0aGlzLnN5c3RlbVN0YXR1cy5sYXN0SGVhcnRiZWF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUNyZWF0ZVNlc3Npb24oYm9keTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSAnc2Vzc2lvbi0nICsgRGF0ZS5ub3coKVxuICAgIGNvbnN0IHNlc3Npb246IE1vY2tBbXBzU2Vzc2lvbiA9IHtcbiAgICAgIGlkOiBzZXNzaW9uSWQsXG4gICAgICBuYW1lOiBib2R5Lm5hbWUgfHwgJ05ldyBTZXNzaW9uJyxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICBwYXJ0aWNpcGFudHM6IDEsXG4gICAgICBxdWV1ZTogW10sXG4gICAgICBzZXR0aW5nczoge1xuICAgICAgICB2b2x1bWU6IDgwLFxuICAgICAgICBzaHVmZmxlOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgLi4uYm9keS5zZXR0aW5nc1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXNzaW9ucy5zZXQoc2Vzc2lvbklkLCBzZXNzaW9uKVxuICAgIHRoaXMuY3VycmVudFNlc3Npb25JZCA9IHNlc3Npb25JZFxuICAgIFxuICAgIHJldHVybiB7IGRhdGE6IHNlc3Npb24gfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVKb2luU2Vzc2lvbihzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHNlc3Npb25JZClcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBub3QgZm91bmQnKVxuICAgIH1cbiAgICBcbiAgICBzZXNzaW9uLnBhcnRpY2lwYW50cysrXG4gICAgc2Vzc2lvbi51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB0aGlzLmN1cnJlbnRTZXNzaW9uSWQgPSBzZXNzaW9uSWRcbiAgICBcbiAgICByZXR1cm4geyBkYXRhOiBzZXNzaW9uIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlR2V0Q3VycmVudFNlc3Npb24oKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFNlc3Npb25JZCkge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25zLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpXG4gICAgcmV0dXJuIHsgZGF0YTogc2Vzc2lvbiB8fCBudWxsIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlTGVhdmVTZXNzaW9uKCk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNlc3Npb25JZCkge1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZClcbiAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgIHNlc3Npb24ucGFydGljaXBhbnRzID0gTWF0aC5tYXgoMCwgc2Vzc2lvbi5wYXJ0aWNpcGFudHMgLSAxKVxuICAgICAgICBzZXNzaW9uLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbklkID0gbnVsbFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQ29udHJvbFBsYXliYWNrKGJvZHk6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHNlc3Npb24nKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zZXNzaW9ucy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKVxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIG5vdCBmb3VuZCcpXG4gICAgfVxuICAgIFxuICAgIHN3aXRjaCAoYm9keS5hY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3BsYXknOlxuICAgICAgICBzZXNzaW9uLnN0YXR1cyA9ICdhY3RpdmUnXG4gICAgICAgIGlmICghc2Vzc2lvbi5jdXJyZW50VHJhY2sgJiYgc2Vzc2lvbi5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRyYWNrID0gc2Vzc2lvbi5xdWV1ZVswXVxuICAgICAgICAgIHNlc3Npb24uY3VycmVudFRyYWNrID0ge1xuICAgICAgICAgICAgaWQ6IG5leHRUcmFjay5pZCxcbiAgICAgICAgICAgIHRpdGxlOiBuZXh0VHJhY2sudGl0bGUsXG4gICAgICAgICAgICBhcnRpc3Q6IG5leHRUcmFjay5hcnRpc3QsXG4gICAgICAgICAgICBkdXJhdGlvbjogbmV4dFRyYWNrLmR1cmF0aW9uLFxuICAgICAgICAgICAgcG9zaXRpb246IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSAncGF1c2VkJ1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3RvcCc6XG4gICAgICAgIHNlc3Npb24uc3RhdHVzID0gJ2luYWN0aXZlJ1xuICAgICAgICBzZXNzaW9uLmN1cnJlbnRUcmFjayA9IHVuZGVmaW5lZFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgIGlmIChzZXNzaW9uLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBuZXh0VHJhY2sgPSBzZXNzaW9uLnF1ZXVlWzBdXG4gICAgICAgICAgc2Vzc2lvbi5jdXJyZW50VHJhY2sgPSB7XG4gICAgICAgICAgICBpZDogbmV4dFRyYWNrLmlkLFxuICAgICAgICAgICAgdGl0bGU6IG5leHRUcmFjay50aXRsZSxcbiAgICAgICAgICAgIGFydGlzdDogbmV4dFRyYWNrLmFydGlzdCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBuZXh0VHJhY2suZHVyYXRpb24sXG4gICAgICAgICAgICBwb3NpdGlvbjogMFxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXNzaW9uLnF1ZXVlLnNoaWZ0KClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAvLyBTaW1wbGUgaW1wbGVtZW50YXRpb24gLSBqdXN0IHJlc3RhcnQgY3VycmVudCB0cmFja1xuICAgICAgICBpZiAoc2Vzc2lvbi5jdXJyZW50VHJhY2spIHtcbiAgICAgICAgICBzZXNzaW9uLmN1cnJlbnRUcmFjay5wb3NpdGlvbiA9IDBcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBcbiAgICBzZXNzaW9uLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTZWVrKGJvZHk6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHNlc3Npb24nKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zZXNzaW9ucy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKVxuICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5jdXJyZW50VHJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHRyYWNrJylcbiAgICB9XG4gICAgXG4gICAgc2Vzc2lvbi5jdXJyZW50VHJhY2sucG9zaXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihib2R5LnBvc2l0aW9uLCBzZXNzaW9uLmN1cnJlbnRUcmFjay5kdXJhdGlvbikpXG4gICAgc2Vzc2lvbi51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlU2V0Vm9sdW1lKGJvZHk6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHNlc3Npb24nKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zZXNzaW9ucy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKVxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIG5vdCBmb3VuZCcpXG4gICAgfVxuICAgIFxuICAgIHNlc3Npb24uc2V0dGluZ3Mudm9sdW1lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBib2R5LnZvbHVtZSkpXG4gICAgc2Vzc2lvbi51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQWRkVG9RdWV1ZShib2R5OiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5jdXJyZW50U2Vzc2lvbklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJylcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZClcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBub3QgZm91bmQnKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBxdWV1ZUl0ZW0gPSB7XG4gICAgICBpZDogJ3F1ZXVlLScgKyBEYXRlLm5vdygpLFxuICAgICAgY29udGVudElkOiBib2R5LmNvbnRlbnRJZCxcbiAgICAgIHRpdGxlOiBgVHJhY2sgJHtib2R5LmNvbnRlbnRJZH1gLFxuICAgICAgYXJ0aXN0OiAnTW9jayBBcnRpc3QnLFxuICAgICAgZHVyYXRpb246IDE4MCwgLy8gMyBtaW51dGVzXG4gICAgICBhZGRlZEJ5OiAnbW9jay11c2VyJyxcbiAgICAgIGFkZGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHByaW9yaXR5OiBib2R5LnByaW9yaXR5IHx8IDBcbiAgICB9XG4gICAgXG4gICAgc2Vzc2lvbi5xdWV1ZS5wdXNoKHF1ZXVlSXRlbSlcbiAgICBzZXNzaW9uLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIFxuICAgIHJldHVybiB7IGRhdGE6IHF1ZXVlSXRlbSB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUdldFF1ZXVlKCk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uSWQpIHtcbiAgICAgIHJldHVybiB7IGRhdGE6IFtdIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZClcbiAgICByZXR1cm4geyBkYXRhOiBzZXNzaW9uPy5xdWV1ZSB8fCBbXSB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVJlbW92ZUZyb21RdWV1ZShxdWV1ZUl0ZW1JZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFNlc3Npb25JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgc2Vzc2lvbicpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25zLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpXG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gbm90IGZvdW5kJylcbiAgICB9XG4gICAgXG4gICAgc2Vzc2lvbi5xdWV1ZSA9IHNlc3Npb24ucXVldWUuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAhPT0gcXVldWVJdGVtSWQpXG4gICAgc2Vzc2lvbi51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlU2VhcmNoQ29udGVudChlbmRwb2ludDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKCdodHRwOi8vbG9jYWxob3N0JyArIGVuZHBvaW50KVxuICAgIGNvbnN0IHF1ZXJ5ID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3EnKSB8fCAnJ1xuICAgIGNvbnN0IGxpbWl0ID0gcGFyc2VJbnQodXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2xpbWl0JykgfHwgJzUwJylcbiAgICBcbiAgICAvLyBNb2NrIHNlYXJjaCByZXN1bHRzXG4gICAgY29uc3QgcmVzdWx0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IE1hdGgubWluKGxpbWl0LCAxMCkgfSwgKF8sIGkpID0+ICh7XG4gICAgICBpZDogYGNvbnRlbnQtJHtpICsgMX1gLFxuICAgICAgdGl0bGU6IGBNb2NrIFRyYWNrICR7aSArIDF9YCxcbiAgICAgIGFydGlzdDogYE1vY2sgQXJ0aXN0ICR7aSArIDF9YCxcbiAgICAgIGR1cmF0aW9uOiAxMjAgKyAoaSAqIDMwKSxcbiAgICAgIGF1ZGlvVXJsOiBgL21vY2stYXVkaW8vdHJhY2stJHtpICsgMX0ubXAzYCxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGdlbnJlOiBbJ1BvcCcsICdSb2NrJywgJ0VsZWN0cm9uaWMnXVtpICUgM10sXG4gICAgICAgIHllYXI6IDIwMjAgKyAoaSAlIDQpLFxuICAgICAgICBicG06IDEyMCArIChpICogMTApLFxuICAgICAgICBrZXk6IFsnQycsICdEJywgJ0UnLCAnRicsICdHJ11baSAlIDVdXG4gICAgICB9XG4gICAgfSkpXG4gICAgXG4gICAgcmV0dXJuIHsgZGF0YTogcmVzdWx0cyB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUdldENvbnRlbnQoY29udGVudElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBjb250ZW50SWQsXG4gICAgICAgIHRpdGxlOiBgTW9jayBUcmFjayAke2NvbnRlbnRJZH1gLFxuICAgICAgICBhcnRpc3Q6ICdNb2NrIEFydGlzdCcsXG4gICAgICAgIGR1cmF0aW9uOiAxODAsXG4gICAgICAgIGF1ZGlvVXJsOiBgL21vY2stYXVkaW8vJHtjb250ZW50SWR9Lm1wM2AsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZ2VucmU6ICdQb3AnLFxuICAgICAgICAgIHllYXI6IDIwMjMsXG4gICAgICAgICAgYnBtOiAxMjAsXG4gICAgICAgICAga2V5OiAnQydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRIZWFydGJlYXQoKTogdm9pZCB7XG4gICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuc3lzdGVtU3RhdHVzLmxhc3RIZWFydGJlYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9LCAzMDAwMClcbiAgfVxuXG4gIC8vIFNpbXVsYXRlIHRyYWNrIHByb2dyZXNzaW9uXG4gIHN0YXJ0VHJhY2tQcm9ncmVzc2lvbigpOiB2b2lkIHtcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50U2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25zLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpXG4gICAgICAgIGlmIChzZXNzaW9uPy5jdXJyZW50VHJhY2sgJiYgc2Vzc2lvbi5zdGF0dXMgPT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgc2Vzc2lvbi5jdXJyZW50VHJhY2sucG9zaXRpb24gKz0gMVxuICAgICAgICAgIGlmIChzZXNzaW9uLmN1cnJlbnRUcmFjay5wb3NpdGlvbiA+PSBzZXNzaW9uLmN1cnJlbnRUcmFjay5kdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gVHJhY2sgZmluaXNoZWQsIHBsYXkgbmV4dFxuICAgICAgICAgICAgaWYgKHNlc3Npb24ucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0VHJhY2sgPSBzZXNzaW9uLnF1ZXVlLnNoaWZ0KCkhXG4gICAgICAgICAgICAgIHNlc3Npb24uY3VycmVudFRyYWNrID0ge1xuICAgICAgICAgICAgICAgIGlkOiBuZXh0VHJhY2suaWQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5leHRUcmFjay50aXRsZSxcbiAgICAgICAgICAgICAgICBhcnRpc3Q6IG5leHRUcmFjay5hcnRpc3QsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG5leHRUcmFjay5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXNzaW9uLmN1cnJlbnRUcmFjayA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9ICdpbmFjdGl2ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2Vzc2lvbi51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEwMDApIC8vIFVwZGF0ZSBldmVyeSBzZWNvbmRcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgbW9ja0FtcHNTZXJ2ZXIgPSBuZXcgTW9ja0FtcHNTZXJ2ZXIoKVxuXG4vLyBTdGFydCB0cmFjayBwcm9ncmVzc2lvbiBzaW11bGF0aW9uXG5tb2NrQW1wc1NlcnZlci5zdGFydFRyYWNrUHJvZ3Jlc3Npb24oKVxuIl0sIm5hbWVzIjpbIk1vY2tBbXBzU2VydmVyIiwiaGFuZGxlUmVxdWVzdCIsImVuZHBvaW50IiwibWV0aG9kIiwiYm9keSIsImNvbnNvbGUiLCJsb2ciLCJoYW5kbGVDb25uZWN0IiwiaGFuZGxlRGlzY29ubmVjdCIsImhhbmRsZUdldFN0YXR1cyIsImhhbmRsZUhlYXJ0YmVhdCIsImhhbmRsZUNyZWF0ZVNlc3Npb24iLCJoYW5kbGVHZXRTZXNzaW9ucyIsImhhbmRsZUdldEN1cnJlbnRTZXNzaW9uIiwiaGFuZGxlTGVhdmVTZXNzaW9uIiwiaGFuZGxlQ29udHJvbFBsYXliYWNrIiwiaGFuZGxlU2VlayIsImhhbmRsZVNldFZvbHVtZSIsImhhbmRsZUFkZFRvUXVldWUiLCJoYW5kbGVHZXRRdWV1ZSIsImhhbmRsZVNlYXJjaENvbnRlbnQiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJzZXNzaW9uSWQiLCJzcGxpdCIsImhhbmRsZUpvaW5TZXNzaW9uIiwicXVldWVJdGVtSWQiLCJoYW5kbGVSZW1vdmVGcm9tUXVldWUiLCJjb250ZW50SWQiLCJoYW5kbGVHZXRDb250ZW50IiwiRXJyb3IiLCJpc0Nvbm5lY3RlZCIsInN5c3RlbVN0YXR1cyIsImNvbm5lY3RlZCIsInN0YXJ0SGVhcnRiZWF0Iiwic3VjY2VzcyIsImRhdGEiLCJjbGllbnRJZCIsIkRhdGUiLCJub3ciLCJjYXBhYmlsaXRpZXMiLCJjdXJyZW50U2Vzc2lvbklkIiwiaGVhcnRiZWF0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidW5kZWZpbmVkIiwibGFzdEhlYXJ0YmVhdCIsInRvSVNPU3RyaW5nIiwic2Vzc2lvbnMiLCJhY3RpdmUiLCJzaXplIiwidG90YWwiLCJzZXNzaW9uIiwiaWQiLCJuYW1lIiwic3RhdHVzIiwicGFydGljaXBhbnRzIiwicXVldWUiLCJzZXR0aW5ncyIsInZvbHVtZSIsInNodWZmbGUiLCJyZXBlYXQiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJzZXQiLCJnZXQiLCJNYXRoIiwibWF4IiwiYWN0aW9uIiwiY3VycmVudFRyYWNrIiwibGVuZ3RoIiwibmV4dFRyYWNrIiwidGl0bGUiLCJhcnRpc3QiLCJkdXJhdGlvbiIsInBvc2l0aW9uIiwic2hpZnQiLCJtaW4iLCJxdWV1ZUl0ZW0iLCJhZGRlZEJ5IiwiYWRkZWRBdCIsInByaW9yaXR5IiwicHVzaCIsImZpbHRlciIsIml0ZW0iLCJ1cmwiLCJVUkwiLCJxdWVyeSIsInNlYXJjaFBhcmFtcyIsImxpbWl0IiwicGFyc2VJbnQiLCJyZXN1bHRzIiwiQXJyYXkiLCJmcm9tIiwiXyIsImkiLCJhdWRpb1VybCIsIm1ldGFkYXRhIiwiZ2VucmUiLCJ5ZWFyIiwiYnBtIiwia2V5Iiwic2V0SW50ZXJ2YWwiLCJzdGFydFRyYWNrUHJvZ3Jlc3Npb24iLCJjb25zdHJ1Y3RvciIsIk1hcCIsInZlcnNpb24iLCJoYXJkd2FyZSIsImF1ZGlvIiwibmV0d29yayIsInN0b3JhZ2UiLCJtb2NrQW1wc1NlcnZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/mock-amps-server.ts\n"));

/***/ })

}]);